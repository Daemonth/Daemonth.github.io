[{"title":"redis和memcache各自的应用场景","date":"2017-06-15T02:58:58.000Z","path":"2017/06/15/aboutadmc/","text":"MySQL+Memcached架构的问题 Memcached采用客户端-服务器的架构，客户端和服务器端的通讯使用自定义的协议标准，只要满足协议格式要求，客户端Library可以用任何语言实现。 Memcached服务器使用基于Slab的内存管理方式，有利于减少内存碎片和频繁分配销毁内存所带来的开销。各个Slab按需动态分配一个page的内存（和4Kpage的概念不同，这里默认page为1M），page内部按照不同slab class的尺寸再划分为内存chunk供服务器存储KV键值对使用（slab机制相当于内存池机制, 实现从操作系统分配一大块内存, 然后 memcached 自己管理这块内存, 负责分配与回收。 内存分配机制介绍 实际mysql是适合进行海量数据存储的，通过Memcached将热点数据加载到cache，加速访问，很多公司都曾经使用过这样的架构，但随着业务数据量的不断增加，和访问量的持续增长，我们遇到了很多问题： 1.MySQL需要不断进行拆库拆表，Memcached也需不断跟着扩容，扩容和维护工作占据大量开发时间。 2.Memcached与MySQL数据库数据一致性问题。 3.Memcached数据命中率低或down机，大量访问直接穿透到DB，MySQL无法支撑。 4.跨机房cache同步问题。 关于memcached问题：Memcache存储大数据的问题 众多NoSQL百花齐放，如何选择 最近几年，业界不断涌现出很多各种各样的NoSQL产品，那么如何才能正确地使用好这些产品，最大化地发挥其长处，是我们需要深入研究和思考的问题，实际归根结底最重要的是了解这些产品的定位，并且了解到每款产品的tradeoffs，在实际应用中做到扬长避短，总体上这些NoSQL主要用于解决以下几种问题 1.少量数据存储，高速读写访问。此类产品通过数据全部in-momery 的方式来保证高速访问，同时提供数据落地的功能，实际这正是Redis最主要的适用场景。 2.海量数据存储，分布式系统支持，数据一致性保证，方便的集群节点添加/删除。 3.这方面最具代表性的是dynamo和bigtable 2篇论文所阐述的思路。前者是一个完全无中心的设计，节点之间通过gossip方式传递集群信息，数据保证最终一致性，后者是一个中心化的方案设计，通过类似一个分布式锁服务来保证强一致性,数据写入先写内存和redo log，然后定期compat归并到磁盘上，将随机写优化为顺序写，提高写入性能。 4.Schema free，auto-sharding等。比如目前常见的一些文档数据库都是支持schema-free的，直接存储json格式数据，并且支持auto-sharding等功能，比如MongoDB。 面对这些不同类型的NoSQL产品,我们需要根据我们的业务场景选择最合适的产品。 redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢? 如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点： 1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 2 、Redis支持数据的备份，即master-slave模式的数据备份。 3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 2. Redis常用数据类型 Redis最为常用的数据类型主要有以下：StringHashListSetSorted setpub/subTransactions在具体描述这几种数据类型之前，我们先通过一张图了解下Redis内部内存管理中是如何描述这些不同数据类型的： 首先Redis内部使用一个redisObject对象来表示所有的key和value,redisObject最主要的信息如上图所示： type代表一个value对象具体是何种数据类型， encoding是不同数据类型在redis内部的存储方式， 比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int,如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:”123” “456”这样的字符串。 这里需要特殊说明一下vm字段，只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的，该功能会在后面具体描述。通过上图我们可以发现Redis使用redisObject来表示所有的key/value数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给Redis不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用，我们随后会具体讨论。 3. 各种数据类型应用和实现方式 String:Strings 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字.常用命令: set,get,decr,incr,mget 等。应用场景：String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类.即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：获取字符串长度往字符串append内容设置和获取字符串的某一段内容设置及获取字符串的某一位（bit）批量设置一系列字符串的内容实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。 Hash常用命令：hget,hset,hgetall 等。应用场景：在Memcached中，我们经常将一些结构化的信息打包成HashMap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。 我们简单举个实例来描述下Hash的应用场景，比如我们要存储一个用户信息对象数据，包含以下信息：用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储，主要有以下2种存储方式： 第一种方式将用户ID作为查找key,把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。 第二种方法是这个用户信息对象有多少成员就存成多少个key-value对儿，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储，如果存在大量这样的数据，内存浪费还是非常可观的。那么Redis提供的Hash很好的解决了这个问题，Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口，如下图： 也就是说，Key仍然是用户ID, value是一个Map，这个Map的key是成员的属性名，value是属性值，这样对数据的修改和存取都可以直接通过其内部Map的Key(Redis里称内部Map的key为field), 也就是通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据,但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。实现方式：上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。List常用命令：lpush,rpush,lpop,rpop,lrange等。应用场景：Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。Set常用命令：sadd,spop,smembers,sunion 等。应用场景：Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。Sets 集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。实现方式：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。Sorted Set常用命令：zadd,zrange,zrem,zcard等使用场景：Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。实现方式：Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。Pub/SubPub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。Transactions谁说NoSQL都不支持事务，虽然Redis的Transactions提供的并不是严格的ACID的事务（比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。","tags":[{"name":"-redis -memcache","slug":"redis-memcache","permalink":"http://yoursite.com/tags/redis-memcache/"}]},{"title":"PHP的性能优化","date":"2017-03-15T02:58:58.000Z","path":"2017/03/15/hello-world/","text":"优化你代码中的瓶颈 Hoare曾经说过“过早优化是一切不幸的根源”。当你想要让你的网站更快运转的时候，你才应该去做优化的事情。当你要改变你代码之前，你需要做的事是什么原因引起了系统缓慢？你可以通过以下指导和其他方式优化你的php，可能是数据库原因也可能是网路原因!通过优化你的php代码，你能尝试着找出你的系统瓶颈。 使用缓存 利用缓存模块（如Memcache）或者模板系统(如Smarty)进行缓存处理。我们可以缓存数据库结果和提取页面结果的方式来提升网站性能。 使用输出缓冲区 当你的脚本尝试着渲染的时候，php会使用内存缓存区保存所有的数据。缓存区可能让你的页面看起来很慢，原因是缓冲区填满所有要响应的数据之后再把结果响应给用户。幸运的是，你能够做一下改变，迫使php强行在缓冲区填满之前把数据响应给用户，这样就会让你的网站看起来更快一些。 避免写幼稚的setters和getters 123456789101112131415161718class dog &#123;public $name = '';public function setName($name) &#123;$this-&gt;name = $name;&#125;public function getName() &#123;return $this-&gt;name;&#125;&#125; 注意：setName()和getName()除了存储和返回name属性外，没做任何工作 123456$rover = new dog();$rover-&gt;setName('rover');echo $rover-&gt;getName(); 避免循环做SQL操作 12345678foreach ($userList as $user) &#123;$query = 'INSERT INTO users (first_name,last_name) VALUES(\"' . $user['first_name'] . '\", \"' . $user['last_name'] . '\")';mysql_query($query);&#125; 过程： 12INSERT INTO users (first_name,last_name) VALUES(\"John\", \"Doe\") 替换这种循环方案，你能够拼接数据成为一个单一的数据库操作。 123456789101112$userData = array();foreach ($userList as $user) &#123;$userData[] = '(\"' . $user['first_name'] . '\", \"' . $user['last_name'] . '\")';&#125;$query = 'INSERT INTO users (first_name,last_name) VALUES' . implode(',', $userData);mysql_query($query PHP性能优化的50个技巧 1、 用单引号代替双引号来包含字符串，这样做会更快一些。因为 PHP 会在双引号包围的 字符串中搜寻变量，单引号则不会，注意：只有 echo 能这么做，它是一种可以把多个字符 串当作参数的“函数”(译注：PHP 手册中说 echo 是语言结构，不是真正的函数，故把函数 加上了双引号)。 2、如果能将类的方法定义成 static，就尽量定义成 static，它的速度会提升将近 4 倍。 3、$row[‘id’] 的速度是$row[id]的 7 倍。 4、echo 比 print 快，并且使用 echo 的多重参数(译注：指用逗号而不是句点)代替字符串 连接，比如 echo $str1,$str2。 5、在执行 for 循环之前确定最大循环数，不要每循环一次都计算最大值，最好运用 foreach 代替。 6、注销那些不用的变量尤其是大数组，以便释放内存。 7、尽量避免使用get，set，__autoload。 8、require_once()代价昂贵。 9、include 文件时尽量使用绝对路径，因为它避免了 PHP 去 include_path 里查找文件的速 度，解析操作系统路径所需的时间会更少。 10、如果你想知道脚本开始执行(译注：即服务器端收到客户端请求)的时刻，使用 $_SERVER[‘REQUEST_TIME’] 要好于 time() 11、函数代替正则表达式完成相同功能。 12、str_replace 函数比 preg_replace 函数快，但 strtr 函数的效率是 str_replace 函数的四倍。 13、如果一个字符串替换函数，可接受数组或字符作为参数，并且参数长度不太长，那么 可以考虑额外写一段替换代码， 使得每次传递参数是一个字符， 而不是只写一行代码接受数 组作为查询和替换的参数。 14、使用选择分支语句(译注：即 switch case)好于使用多个 if，else if 语句。 15、用@屏蔽错误消息的做法非常低效，极其低效。 16、打开 apache 的 mod_deflate 模块，可以提高网页的浏览速度。 17、数据库连接当使用完毕时应关掉，不要用长连接。 18、错误消息代价昂贵。 19、在方法中递增局部变量，速度是最快的。几乎与在函数中调用局部变量的速度相当。 20、递增一个全局变量要比递增一个局部变量慢 2 倍。 21、递增一个对象属性(如：$this-&gt;prop++)要比递增一个局部变量慢 3 倍。 22、递增一个未预定义的局部变量要比递增一个预定义的局部变量慢 9 至 10 倍。 23、仅定义一个局部变量而没在函数中调用它，同样会减慢速度(其程度相当于递增一个局 部变量)。PHP 大概会检查看是否存在全局变量。 24、方法调用看来与类中定义的方法的数量无关，因为我(在测试方法之前和之后都)添加了 10 个方法，但性能上没有变化。 25、派生类中的方法运行起来要快于在基类中定义的同样的方法。 26、调用带有一个参数的空函数，其花费的时间相当于执行 7 至 8 次的局部变量递增操作。 类似的方法调用所花费的时间接近于 15 次的局部变量递增操作。 27、Apache 解析一个 PHP 脚本的时间要比解析一个静态 HTML 页面慢 2 至 10 倍。尽量 多用静态 HTML 页面，少用脚本。 28、除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套 PHP 缓存机制通常 可以提升 25%至 100%的性能，以免除编译开销。 29、尽量做缓存，可使用 memcached。memcached 是一款高性能的内存对象缓存系统， 可用来加速动态 Web 应用程序，减轻数据库负载。对运算码 (OP code)的缓存很有用，使 得脚本不必为每个请求做重新编译。 30、 当操作字符串并需要检验其长度是否满足某种要求时， 你想当然地会使用 strlen()函数。 此函数执行起来相当快，因为它不做任何计算，只返回在 zval 结构(C 的内置数据结构，用 于存储 PHP 变量)中存储的已知字符串长度。但是，由于 strlen()是函数，多多少少会有些 慢，因为函数调用会经过诸多步骤，如字母小写化(译注：指函数名小写化，PHP 不区分函 数名大小写)、哈希查找，会跟随被调用的函数一起执行。在某些情况下，你可以使用 isset() 技巧加速执行你的代码。 (举例如下) if (strlen($foo) &lt; 5) { echo “Foo is too short”$$ } (与下面的技巧做比较) if (!isset($foo{5})) { echo “Foo is too short”$$ } 调用 isset()恰巧比 strlen()快，因为与后者不同的是，isset()作为一种语言结构，意味着它 的执行不需要函数查找和字母小写化。 也就是说， 实际上在检验字符串长度的顶层代码中你 没有花太多开销。 31、当执行变量$i 的递增或递减时，$i++会比++$i 慢一些。这种差异是 PHP 特有的，并不 适用于其他语言， 所以请不要修改你的 C 或 Java 代码并指望它们能立即变快， 没用的。 ++$i 更快是因为它只需要 3 条指令(opcodes)，$i++则需要 4 条指令。后置递增实际上会产生一 个临时变量，这个临时变量随后被递增。而前置递增直接在原值上递增。这是最优化处理的 一种，正如 Zend 的 PHP 优化器所作的那样。牢记这个优化处理不失为一个好主意，因为 并不是所有的指令优化器都会做同样的优化处理， 并且存在大量没有装配指令优化器的互联 网服务提供商(ISPs)和服务器。 32、并不是事必面向对象(OOP)，面向对象往往开销很大，每个方法和对象调用都会消耗很 多内存。 33、并非要用类实现所有的数据结构，数组也很有用。 34、不要把方法细分得过多，仔细想想你真正打算重用的是哪些代码? 35、当你需要时，你总能把代码分解成方法。 36、尽量采用大量的 PHP 内置函数。 37、如果在代码中存在大量耗时的函数，你可以考虑用 C 扩展的方式实现它们。 38、 评估检验(profile)你的代码。 检验器会告诉你， 代码的哪些部分消耗了多少时间。 Xdebug 调试器包含了检验程序，评估检验总体上可以显示出代码的瓶颈。 39、mod_zip 可作为 Apache 模块，用来即时压缩你的数据，并可让数据传输量降低 80%。 40、在可以用 file_get_contents 替代 file、fopen、feof、fgets 等系列方法的情况下，尽量 用 file_get_contents，因为他的效率高得多!但是要注意 file_get_contents 在打开一个 URL 文件时候的 PHP 版本问题; 41、尽量的少进行文件操作，虽然 PHP 的文件操作效率也不低的; 42、优化 Select SQL 语句，在可能的情况下尽量少的进行 Insert、Update 操作(在 update 上，我被恶批过); 43、尽可能的使用 PHP 内部函数(但是我却为了找个 PHP 里面不存在的函数，浪费了本可 以写出一个自定义函数的时间，经验问题啊!); 44、 循环内部不要声明变量， 尤其是大变量： 对象(这好像不只是 PHP 里面要注意的问题吧?); 45、多维数组尽量不要循环嵌套赋值; 46、在可以用 PHP 内部字符串操作函数的情况下，不要用正则表达式; 47、foreach 效率更高，尽量用 foreach 代替 while 和 for 循环; 48、用单引号替代双引号引用字符串; 49、“用 i+=1 代替 i=i+1。符合 c/c++的习惯，效率还高” 50、对 global 变量，应该用完就 unset()掉;","tags":[]}]